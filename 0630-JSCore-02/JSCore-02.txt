1、【***函数】：
	1、什么是函数：封装一项任务步骤清单的代码段，再起一个名字
	2、为什么使用函数：一项任务可能会被反复执行，而直接顺序编写的代码，无法重复利用，不便于维护。
	3、何时使用函数：只要一项任务 可能被反复执行时，
	   都要先将任务定义在一个函数中，再反复调用函数。
	4、优点：代码重用
	5、如何定义：
		声明：在内存中创建一个函数对象，来封装函数的定义
		function 函数名(参数列表){
			步骤清单;
			return 返回值;
		}
	6、三要素：
		1、 参数：接收函数执行时必要数据的变量
			何时定义参数：当一项必须某些数据才能正常执行时，都要定义对应的参数。
			如何定义参数："在函数名后的()中，不要var即可直接定义参数变量名"。每个参数变量之间用逗号分隔。
				作用：1、提示调用者必须提供哪些数据才能正常执行
					  2、让函数变得更灵活
		2、步骤清单
		3、返回值：函数的执行结果
			何时定义：如果调用者需要获得函数的执行结果时。
			如何定义：return 返回值
					  退出函数
		函数是一个"引用类型的对象"：
			声明：1、用函数名定义一个变量；
				  2、创建函数对象，封装定义函数；
				  3、让函数名变量引用函数对象
		调用：找到函数，并按照函数的步骤清单执行程序。
		如何调用：
			var 返回值 = 函数名(参数值列表);
			参数值列表，尽量要和声明时的参数值列表中的个数和书序一致。
			return只负责返回结果，不负责保存。
	7、【***作用域(scope)】：一个变量的可用范围
		2种：
			1、全局作用域：window
				全局变量：保存在全局作用域中的变量
					特点：随处可用，可反复使用
			2、函数作用域：
				局部变量：在函数调用时，保存在函数作用域中的变量
					特点：仅在函数内可用，不可重复使用
				作用域规定了变量使用的顺序和优先级：
					只要局部有，就不用全局的
					局部没有，才去全局找
					全局也没有就报错
				函数调用的过程：
					1、引擎找到函数定义
					2、创建函数作用域
						在函数作用域中保存局部变量
					3、调用时，优先使用函数作用域中的局部变量。
						除非局部没有，采用全局的。
					4、函数调用后，函数作用域释放
						其中的局部变量一同释放。
				eg:
				//例1、
					var a=10;
					function fun(){
						a++;			//借用全局的a,把全局的变量a递增了1
						console.log(a);	//11
					}
					fun();				//11
					console.log(a);		//11,全局变量已经被修改了
				//例2、
					var a=10;
					function fun(){
						var a=20;
						a++;			//局部
						console.log(a);	//21
						console.log(c);
					}
					fun();				//21
					console.log(a);		//10,全局变量
				//例3、
					var a=10;
					function fun(a){	//带参后，相当于在函数内
										  隐式声明了一个变量a，是局部变量 
						a++;			//但未赋值，所以输出NaN
						console.log(a);
					}
					fun();				//NaN
					console.log(a);		//10
				//例4、
					var a=10;
					function fun(a){	//带参后，相当于在函数内
										  隐式声明了一个变量
						a=20;			//赋值
						a++;
						console.log(a);
					}
					fun();				//21
					console.log(a);		//10
	8、【声明提前(hoist)】：
		在正式执行程序前，都会将所有"var声明的变量 和 function 声明的函数
		提前到"当前作用域的顶部"集中创建

			eg:
			//例1、
				var a=10;
				function fun(a){		//传参,把a传了过来
					console.log(a);				//10	全局
					a=100;
					console.log(a);				//100	局部
				}
				fun(10);				//10	100
				console.log(a);			//10	全局
			//例2、
				var a=10;
				function fun(){			//未传参
					console.log(a);				//undefined
					var a=100;
					console.log(a);				//100
				}
				fun();					//undefined		100
				console.log(a);			//10
			//例3、
				经过运行测试，可以得到正确结果的两端代码段：
			代码段：								恢复后的代码段：
			fun();		//	2					=>	var fun;	//仅声明提前
			fun();		//	2					=>	function fun(){console.log(1);}
			function fun(){console.log(1);}		=>	function fun(){console.log(2);}
			function fun(){console.log(2);}		=>	fun();		//2	因为函数在执行后就被销毁了，所以函数1已经不存在了，执行了两遍函数2
			var fun=100;						=>	fun();		//2
			fun();		//TypeError: 			=>	fun=100;	//赋仍然保留在原位
						//fun is not a function	=>	fun();		//TypeError:fun is not a function

	9、按值传递:两个变量间赋值时，或者"将变量作为函数的参数"传入函数时。
		其实，只是"将【原变量中的值】"复制一个副本给对方
		后果：
			【原始类型的值】：修改新变量，不影响原变量；
			eg1:
				function buy(card){
					card-=3;
					console.log("余额 "+card);		//7
				}
				var card=10;		//var声明的变量会被提前
				buy(card);	//7	按值传递，即将实参变量的值复制一份副本给方法的形参变量
				console.log(card);	//10
			【引用类型的对象】：复制的是"【对象地址】"的一个副本，原对象依然只有一个。
				结果：新旧变量同时引用同一个对象。
					结果任何一方修改，另一方都受影响。
			eg2:
				function eat(baos){
					baos.length--;
					console.log(String(baos));
				}
				var baos=["包","包","包","包","包",];	//数组，
				eat(baos);		//"包","包","包","包"
				console.log(String(baos));		//"包","包","包","包"
2、全局函数
	ES标准中规定的，浏览器厂商已经实现的，不需要任何对象就可直接调用的函数
		W3C离线手册-->JavaScript-->JavaScript对象-->JS Functions 中
		parseInt();
		parseFloat();
		isNaN(num);
		...			//alert();  不是全局函数，属于 BOM
					//getElementById();	--> DOM 
	其他全局函数：
		编码解码：(不是加密)
			问题1：
				URI标准不允许使用"多字节字符"，如果使用会乱码。汉字属于多字节字符
				解决：（所以要）将多字节字符编码为单字节字符
					【采用utf-8编码：一个汉字  3字节】
				如何编码：
					var code=encodeURI(str);
				如何解码：
					var code=decodeURI(str);
				eg:
					var wd=prompt("百度一下");
					alert("http://www.baidu.com/s?wd"+encodeURI(wd));
					alert("服务器解码"+'\n'+"http:www.baidu.com/s?wd="+decodeURI(wd));

			问题2：
				URI标准还不允许使用"保留字符"：
					比如：	:	/
				encodeURI 和 decodeURI 无法编码解码保留字符
				解决：
					encodeURIComponent() 编码
					decodeURIComponent() 解码
					既可编码保留字符，又可编码多字节字符
		eval：执行字符串格式的js代码
		isFinite：判断一个数值是否在有效范围内
			js中除数为0，不会报错，而是返回infinity。
				  判断一个数是不是无穷大：
				  isFinite(num); 返回true，说明num 在有效范围内
								 返回false，说明num是无穷大
/*************************************************************************/
/***利用分支结构的特点简化代码：短路逻辑、三目运算符、switch case语句*****/
/************************************************************************/
3、分支结构：
	什么是分支结构：让程序根据不同的条件执行不同的操作。
	包括：
		1、一个条件，一件事，满足就做，不满足就什么也不做。
			如果操作简单：利用短路逻辑实现：
				短路：条件&&操作	即只有满足"条件"，才"操作"
			如果操作复杂：使用if结构：
				if(条件){
					操作;
				}
		2、一个条件，两件事，二选一执行
			如果操作简单：三目（三元/条件）运算
				如何使用：条件?操作1:操作2;
					如果满足条件，执行操作1，否则执行操作2
				"如果根据不同的条件选择不同的值"时，也可以：
					三目：条件?值1:值2
					如果满足条件，就用值1，否则用值2
						
					eg：【【判断平年闰年】】
						console.log((y%4==0&&y%100!=0||y%400==0)?"闰年":"平年");
			如果操作复杂：
				if(条件){
					满足条件才执行的代码段
				}else{
					不满足条件才执行的代码段
				}
		3、多个条件，多件事，多选一执行：
			如果操作简单：三目
				条件1?操作1:
				条件2?操作2:
				  ...?  ...:
				   默认操作;	//【该步不能省略】，不同于下一个复杂操作中的步骤
				  eg：
					计算可莱托指数
					function clt(h,w){	//传入两个参数，身高体重
						var r=w/(h*h);
						console.log(r>25?"胖":r<20?"瘦":"正常");
					}
					clt(1.75,64);
			如果操作复杂：
				if(条件1){
					操作1;
				}else if(条件2){
					操作2;
				}else if(...){
					...
				}else{		//该步也可省略
					默认操作;
				}
		4、如果所有条件都是等于比较时：
			switch case
			如何使用：
				switch(表达式){
					case 值1:
						操作1;
					case 值2:
						操作2;
					case ...:
						.... ;
					default:	//可省略
					默认操作
				}
			执行原理：
				先计算表达式的值，用该值依次和每个case后的值做 全等===比较。
				如果表达式的值 全等于 某个case的值，则进入该case下执行内部的操作
				默认情况下，执行完当前case中的操作后，会继续触发之后所有的case操作
				解决：
					break;		//退出当前结构
						一般在每个case之间用break阻断传导。
				何时不需要break？
					1、最后一个操作后，不加 break
					2、相邻两个case执行相同的操作时，不加break。
			注意：
				switch case 和 else if
				前者 仅用于等于比较的条件
				后者可用任意条件
				
				if (Boolean(条件)) else if()
					自带隐式转换，将条件转为boolean，效率稍微低
				switch case
					不带隐式转换的等于比较，效率稍微高。

	作业：c语言100题：T1、T11、T12、T13、T14、T16、T21、T22、