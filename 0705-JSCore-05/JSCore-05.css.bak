1、***String字符串
	截取子字符串：3种方式：
		1、str.slice(starti,endi+1)
			用法同数组的slice：
				1、含头不含尾
				2、"支持负数参数"
				3、省略第二个参数的话，表示截到结尾
		2、str.substring(starti,endi+1)
			特点：
			相同：
				1、含头不含尾
				2、省略第二个参数的话，表示截到结尾
			不同："不支持负数参数"
				如果使用倒数第n位，用 length-n
		3、str.substr(starti,n)
			从starti开始，截取n个。不用考虑含头不含尾
	
	***"查找关键词"：4种方法：
		1、查找一个固定的关键词 的 【位置】
			1、var i=str.indexOf("关键词",fromi);
				在str中从from位置开始，找到下一个“关键词”所在位置。
				返回值：
					如果找到，返回关键词第一个字符的下标位置
					如果没找到，返回 -1
				特殊：如果省略 fromi 表示 从0位置开始。
				强调：indexOf每次只找fromi 之后的 下一个 关键词
				解决：用循环反复调用indexOf
					每次都将fromi改为当前位置之后，直到返回-1结束

			2、var i=str.lastindexOf("关键词",fromi);
				在str中从fromi位置开始，找前一个“关键词”所在的位置。
				返回值：同indexOf
				特殊：省略fromi表示从length-1开始。
		何时使用：只要查找一个固定的关键词的位置
		问题：无法使用 模式匹配 的方式查找关键词。
			  即不支持正则

		2、判断是否包含 和正则表达式匹配的 关键词：（支持正则）
			1、var i=str.search(/正则表达式/i);
				表示：在str中查找第一个和正则匹配的关键词的位置
				说明：第二个/后+i，表示不区分大小写
							不加，默认区分大小写
				强调："search永远只能返回第一个关键词的位置"
					"不能返回关键词的内容，也无法获得之后更多的关键词"。
				返回值：如果找到，返回关键词的位置
						如果没找到，返回 -1
				存在问题：
					永远只能找第一个且无法获得关键词的准确内容。
		
		3、获取所有关键词的  【内容】：
			var kwords=str.match(/正则/ig);
				表示 获取str中所有  和正则匹配的关键词，将其 保存在结果数组 中。
				说明：g表示全部。
					如果不加g，默认只查找第一个。
					如果没找到，返回 null ！
					今后，都要先判断是不是null，再操作
						eg:
							console.log(kwords!=null ? "共找到"+kwords.length+"个关键词"+String(kwords) : "没找到");
					
					如果不加g：会将完整关键词放在数组的第0个元素。同时为数组添加index属性，标记关键词的位置。
					如果正则中包含分组，还会将每个分组匹配的子内容，分别放在数组的后续元素中。
					存在的问题："只能获得内容，无法获得每个关键词的位置"。
					解决：参见第4种方法
		4、可获得每个关键词的  【内容和位置】
			reg.exec()
			......[下一天待续]

	***"替换"：
		var str=str.replace(/正则/ig,"替换值")
			表示：将str中所有和正则匹配的关键词都替换为“替换值”，再将生成的新字符串，存回str。
		高级替换：		//把函数作为参数传入
			str=str.replace(/正则/ig,function(kword){
				return '替换值';
			});
			eg：
				str=str.replace(/我[去草]{1,2}/g,function(kword){
					return kword.length==2 ? "**" : "***";
					}
				);
				
				依次找到str中每个和正则匹配的关键词，传给函数的kword参数。
				函数内根据本次找到的关键词，计算出不同的替换值。
				replace会将函数返回的替换值，替换到字符串。

		如果需要 部分替换关键词：
			1、将正则表达式分组：
			2、从函数的第二个参数开始，依次获得每次匹配的关键词的分组内容。
			eg：
				//该段代码实现：匹配 我去、我去去 或者 我草、我草草，然后把 去、去去 或 草、草草 字替换成 *、** 号。
				str=str.replace(/我[去草]{1,2}/g,function(kword,$1,$2){
					return $1+($2.length==1 ? "*" : "**");
					}
				);
		衍生功能：
			删除：其实就是将关键词替换成字符串""。
			格式化：需要2步：
					1、用正则将  要格式化的字符串分组
					2、在replace的第二个参数中，用$n代替第n个分组的子内容，拼接格式。

	***"分隔"：将str按照指定的分隔符，分割为多个子字符串。
		var subs=str.split("分隔符");
				 str.split(/正则/);		//如 当天练习 05-分离邮箱账号中 用户名 与 域名
		
		固定套路：
			1、将字符串打散为"字符数组"：
				var chars=str.split("");
			2、按指定字符分隔：
				var 


2、*****正则表达式
	什么是正则表达式：
		描述一个字符串中，字符出现规律的规则
	为什么：可以使用模式进行模糊匹配
	何时使用：查找，替换，切割，验证
	如何使用：
		1、最简单的正则 就是关键词原文
		2、字符集：
			规定一位字符可用的 备选字符 列表
			何时使用：只要某一位字符，有多个备选时
			如何使用：[备选字符的列表]
			强调：1个字符集，默认只能匹配一位字符
			简写：如果字符集中的字符，部分unicode连续，可用 - 省略中间的简写
				比如：1位数字：[0-9]
					  1位小写字母：[a-z]
					  1位字母：[A-Za-z]
					  1位汉字：[\u4e00-\u9fa5]
				如果表示 除了xxx之外，用 [^xxx]
		3、预定义字符集：
			对常用字符集的简化：
			1位数字：\d  =>  [0-9]
			1位字母数字或下划线：\w  =>  [0-9A-Za-z]
			1位空字符：\s  =>  空格，换行，制表符
			1位任意字符：.  =>  除回车、换行外的一切字符
			何时使用：
				如果需求和预定义字符集完全匹配，才能使用
				如果需求和预定义字符集不匹配，就必须使用普通字符集
		4、量词：
			规定一个字符集出现次数的规则
			2类：
				有明确数量限制的：
					字符集{min,max}		字符集最少出现min次，最多不能超过max次
					字符集{n,}		匹配字符n的出现次数 >=n 次
					字符集{n}       匹配字符集必须 n 个
				没有明确数量限制：
					？	0次或1次   即可有可无，最多1次
					*	>=0次	   即0次或多次字符
					+	>=1次	   即1次或多次  至少1个 ，多了不限
		5、选择和分组
			选择：|  表示：或	   正则1|正则2   表示只要和任意一个正则匹配，就符合规则。
			分组：()划分子表达式
		
		"在线分析正则表达式的网站"：
		"http://regexper.com/"

		6、匹配指定位置
			^	字符串开始位置
				读作 ”以xxx开头“ 或 开头的”xxx“
				强调：放在正则的开头，表示字符串的开始位置
					  放在字符集[]内部的开头，表示除了xxx
			$	字符串结束位置
				xxx$   读作： 以xxx结尾
				强调：如果同时前加^，后加$，表示必须从头到尾完整匹配。	--验证功能
					  如果不加，只要部分匹配就会验证通过
			\b  匹配单词边界	开头，结尾，空格，字符
				\b单词\b
		
		【"密码强度"】：预判  排除法
			eg:
				至少包含一位大写字母以及一位数字
				1、预判："不都是 小写字母和数字 组成"
					说明 至少包含一位 大写字母 或 其他字符
					(?![a-z0-9]+$)
				2、预判："不都是 字母 组成"
					说明至少包含一位数字或其他字符
					(?![A-Za-z]+$)
				3、正则："只能由 字母和数字 组成"
					排除了之前 其他字符的可能
					[A-Za-z0-9]{8,10}
				放在一起：在前后加上 ^ 、$
					^(?![a-z0-9]+$)(?![A-Za-z]+$)[A-Za-z0-9]{8,10}$