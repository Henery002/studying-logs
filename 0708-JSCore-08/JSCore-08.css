回顾：
	1、闭包：
		什么是：重用并保护一个局部变量的机制

			'因为外层函数的作用域无法被释放。'

		为什么：
			全局变量、局部变量
		何时：希望重用一个变量又不希望被篡改时
		如何使用：3步
			1、用外层函数包裹受保护的变量和操作变量的函数
			2、外层函数将内层函数返回
			3、使用者调用外层函数调用内层函数的返回对象。

		笔试题：（步骤）
			1、找受保护的变量是谁。
			2、找操作变量的函数。
			3、同一次外层函数调用返回的所有内层函数对象，共用同一个受保护的局部变量
			4、两次外层函数调用，返回的不同内层函数的对象，所操作的变量没有任何关系。

		闭包返回内层函数对象：
			1、return
			2、直接给全局变量赋值
			3、将内层函数封装在一个对象中，然后返回对象。
		闭包的缺点：
			占用更多内存空间
正课：
1、*****面向对象（OOP）
	对象：
		1、专门描述现实中一个具体事物的属性和功能的一种程序结构
			事物的属性会成为对象的属性，事物的功能会成为对象的方法。
		2、其实质：内存中同时存储多个数据和方法的一块存储空间
	面向对象：
		在程序中，都是先用对象来封装一个事物的属性和功能。然后再调用对象的方法来执行任务。
		为什么面向对象如此流行？：
			符合人的日常习惯。
		如何使用：2步
			1、创建对象：2个场景
				1、创建一个单独的对象：3种方法
					1、对象直接量：【'习惯于使用第一种'】

						var obj={
							'属性名':属性值,
								... :...;
							'方法名':function(){...}
						}

						【何时使用】：
							"如果创建对象时，已经知道对象的所有属性和方法时"。
						对象的属性和方法统称为对象的成员
						对象中的每个成员名，都是字符串类型
							但是，可省略""。
						
						问题：对象的方法中，不能写死对象的属性
						解决：在对象的方法中，直接访问对象当前对象自己的属性
							this 关键词：专门用在对象的方法中，用来指代正在调用方法的当前对象本身。
							其实就是调用方法时，点"."前的对象

							总结：只要在对象 的方法中访问对象自己的属性，必须用this.属性名
					2、使用new关键词：

						var obj=new Object();	//先创建空对象
						var obj={};

						obj.属性名=值;		//再添加属性
						obj.方法名=function(){
							...this.属性...
						}
							
						补：new和()?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
						

						【何时使用】：
							"在创建对象时，还不知道对象的属性和方法，需要后续动态添加"
						*****【说明：JS中一切对象都是关联数组】
							对象与数组的相同：
								1、属性名都是字符串，不可重复
								2、随时添加新属性和方法
								3、可用for in 遍历
					
				2、批量创建多个相同结构的对象：2步：
					1、定义构造函数：
						构造函数：专门定义类型对象统一结构的特殊函数。
						为什么使用：
							为代码重用
						何时使用：今后只要反复创建多个相同结构的对象前，都要用构造函数先定义统一的结构。
						如何定义：

							function 类型名/构造函数名(属性参数,...){
									//this：当前正在创建的空对象
									//向当前空对象中添加新的属性
								this.属性名=属性参数;
									//向当前空对象中添加新的方法
								this.方法名=function(){
									...
								}
							}
					2、用new关键字调用构造函数创建新对象：
						var obj=new 构造函数名(属性值);
							
							这里new做了4件事：
								1、创建一个空对象
								2、"设置新对象的 _proto_ 继承构造函数的原型对象"
								3、用新对象调用构造函数	
									构造函数会向新对象中添加属性和方法。
								4、将新对象地址返回给obj

			2、访问对象的成员：
				访问属性：对象.属性
					单个对象属性的用法和变量完全一样。
				调用方法：对象.方法(参数)
					找到“对象”的“方法”，执行。

	面向对象三大特点：封装、继承、多态
		继承：父对象的成员，子对象不必重新创建就可以直接使用。
		JS中的继承都是通过原型对象实现的。
		原型和原型链：
			原型：保存一类对象共有成员的父级对象
				为什么使用原型对象：为了实现继承
					"优点：代码重用、节约内存。"
				何时使用原型对象：
					只要一类对象共有的成员，都必须集中定义在原型对象中一次即可。
				如何使用原型对象：
					创建：在定义构造函数时，JS会自动创建该类型的原型对象
					向原型对象中添加其他成员：
						构造函数.prototype.成员名=值

				内置对象的原型对象：
					可解决浏览器的兼容性问题：
						如果需要的API，在指定类型的原型对象中不存在，说明不支持
						就要在该类型的原型对象中添加所需的共有成员。
						其中在API内部，用this获得当前正在调用API的点前的对象

			原型链：由各级父对象，各级继承形成的链式结构
				控制着对象成员（属性和方法）的使用顺序：
					优先使用对象本地的成员 ---- 自有属性
					如果本地没有，才沿着原型链向上查找各级父对象。直到找到为止。 ---- 共有属性
					如果整个原型链上没有，才返回undefined
			怎样判断成员是 自有属性 还是 共有属性？
				1、判断自有属性：
					obj.hasOwnProperty("属性名")
						用于判断“属性名”是否是obj的自有属性
							保存在obj对象本地
							是自有属性就返回true，否则返回false
				2、判断共有属性
					问题：如果不是自有属性：
						1、可能在原型链上
						2、也可能根本没有
					解决：不是自有，且可以访问到
						!obj.hasOwnProperty('属性名') && obj.属性名!=undefined
					
					"如何操作自有属性和共有属性"：
						自有属性，只能用所在对象去【修改】
						共有属性，必须通过原型对象去【修改】

						如果强行使用某个子对象，修改共有属性，
							后果：仅在当前子对象添加同名自有属性
								导致：当前子对象无法再使用共有属性。
					
					删除属性：
						delete 对象.属性

			【亲子鉴定】：给对象做亲子鉴定
				1、用原型对象检查：
					var bool=father.isPrototypeOf(child)

						判断child是否继承自father
							father是否在child的原型链上
							如果father在child的原型链上，返回true
												否则	返回false
				2、用构造函数检查
					var bool=child instanceOf 构造函数

						判断child是否是构造函数创建出来的子对象
					
					补：instance实例：（实例化）
						用一个构造函数创建出来的一个子对象，就称为子对象时构造函数的实例
						eg:
							var obj=new 构造函数();
								实例化一个 构造函数 类型的对象
						eg：实例化一个数组类型的对象arr：
							var arr=new Array();
	
		多态：同一个函数，在不同情况下，表现出不同的状态
			重写(override)：如果子对象觉得父对象的成员不好用，
				就可在子对象本地重新定义同名成员，覆盖父对象的成员。
			
			call：强行借用一个本来无法调用到的函数
				目标函数.call(obj)

				执行时：相当于obj.目标函数
			




