1、***错误处理
	什么是错误（bug）：在程序过程中导致程序异常中断的问题。
	Error：在错误发生时，保存错误信息的"对象"。
		JS中的6种错误：
			SyntaxError：语法错误
			ReferenceError：引用错误，没找到xxx
			TypeError：类型错误，错误的使用了对象的方法。
			RangeError：范围错误，特指参数超范围
			EvalError：错误的使用了eval
			URIError：URI错误
		任何程序发生错误时，都会强行退出

		错误处理：在程序发生错误时，保证程序不会强行退出的机制。
			如何处理：
				try{
					可能出现错误的代码
				}catch(err){
					只有发生错误时，才执行的错误处理代码
				}finally{
					无论是否出错，都必须执行的代码
					//主动保存数据
					//释放资源
				}
				eg：例题01、02

			err对象是在错误发生时JS自动创建的

			"效率：一段正常代码，只要放入try中，执行效率一定降低"。
			解决：
				1、try中应仅放可能出现问题的代码。
				2、如果可以提前预知的异常处理，都可通过 if...else 代替 try...catch...

			可用于解决浏览器兼容性问题：
				判断浏览器是否支持Ajax:
				//用try catch判断浏览器兼容性：
				try{
					new XMLHttpRequest();
					document.write("完美支持Ajax");
				}catch(err){
					document.write("您的浏览器不支持Ajax");
				}

		抛出自定义错误：
			何时：函数的定义者向函数的调用者提醒  错误地使用了函数。
			如何：
				函数定义者：throw new Error("错误提示");
				函数调用者：用 if...else... 或 try...catch 处理异常
				eg：
					例-01
2、*****Function
	什么是函数对象：在内存中封装一个 函数定义的对象。
	何时使用：代码重用
	创建：3种方式
		1、声明：function 函数名(参数列表){
					函数体;
					return 返回值;
				}
			强调：被整体声明提前
		2、函数直接量：var 函数名=function(参数列表){...};
			强调："函数直接量（等号右边的部分）不会被声明提前"
			何时使用：只要不希望被声明提前时
			揭示：函数其实是引用类型的对象
				  函数名其实仅是一个引用函数对象的普通变量
		3、用 new 关键字：
			var 函数名=new Function("参数1","参数2", ... ,
									"函数体 ; return 返回值");
			eg：例-04
	
	1、重载
		什么是重载：
			相同函数名、不同参数列表的多个函数，在调用时可【自动】根据传入的参数不同，调用不同的函数执行。
		为什么使用：
			相同的任务就应该起相同的函数名来减轻调用者的负担。
		何时使用：
			【"同一件事，根据传入参数的不同，执行不同的逻辑时"】。
		如何实现：
			JS的语法不支持重载！
			因为JS中不允许包含多个同名函数。最后定义的同名函数会覆盖之前定义的。
		解决：arguments
			arguments：是每个函数中"【自动创建的】"、用于保存所有传入函数的参数值的【"类数组对象"】。
			
		==> 【类数组对象】：长得像数组的对象，"但不是数组"	vs  数组：
			相同：1、可用下标访问每个元素	==>	例05
				  2、都有length属性
				  3、使用for遍历
			不同：类型不同
				数组：Array
				类数组对象：Object
				无法使用数组类型的API
			
			arguments.callee ：（自己）	引用了当前函数对象。专门实现递归调用。
				eg:例-06
			arguments.callee.caller ：（调用自己的别人）  表示调用当前函数的外层函数
			
	2、匿名函数
		什么是匿名函数：
			定义函数时，不使用任何变量引用的函数。
				function (){
					return a-b;
				}
		为什么使用：节约内存
			因为没有任何变量使用，使用完立刻释放。
		何时使用："如果一个函数只用一次，就必须用匿名函数"。
		如何使用：
			1、匿名函数自调：创建完函数，立刻执行。
				(function(...){...})()
					执行后，匿名函数被释放。
				作用：1、节约内存
					  2、充当临时作用域
			2、匿名函数回调：将函数传给另一个函数使用
				比如：【比较器函数】：
					  【比较器函数】：
					  【比较器函数】：
					var cmp=function(a,b){return a-b}
					arr.sort(cmp);
				==>
					arr.sort(function(a,b){return a-b});
							//cmp 没用了
					//"今后一律用这种方式写比较器函数"
	3、****作用域和作用域链
		函数的生命周期：4个阶段：
			1、程序开始执行时：
				1、创建一个 Execution Context Stack(ECS)，
					是  依次保存正在调用的函数的  "执行环境"的栈结构；
				2、创建全局作用域对象：window；
				3、在ECS中压入第一个全局执行环境。
			2、定义函数时：
				1、创建函数对象，封装函数的定义；
				2、在函数对象中，设置scopr属性，引用函数来自的作用域，通常scopr都是window；
				3、用函数名创建全局变量，引用函数对象。
			3、调用函数时：
				1、创建一个活动对象 Actived Object(AO):
					活动对象：保存函数的局部变量的函数作用域对象；
				2、向ECS中压入本次函数调用的执行环境EC；
				3、EC引用AO；
				4、设置AO引用函数的scope(window)。
			4、函数调用后：
				1、EC出栈，导致AO无人使用，而被释放。
					导致AO中的局部变量一同被释放！
			
			作用域：一个变量的可用范围
				其实window对象就是全局作用域
					"AO对象就是函数作用域"
					AO对象又引用了window对象
			作用域链：由各级作用域链对象，逐级引用形成的链式结构，就是作用域链。
				作用域链的末尾是window对象。
				作用域链控制着变量的使用顺序：
					优先使用AO中的局部变量，
					如果AO中没有，就沿着作用域链向下找，
					如果到window还没找到，就报错。
			
			【笔试题】：
				......
	4、闭包
		什么是闭包："既重用变量，又保护变量不受污染的机制"。
		为什么使用：
			全局变量的优点：随处可用、可反复使用
					  缺点：容易被全局污染
			局部变量的优点：仅在函数内使用，不会被污染
					  缺点：无法反复使用
		何时使用：如果希望重用一个变量，且不希望该变量被随意篡改时。
		如何实现：3步：
			1、用外层函数将  受保护的变量和操作变量的函数  封装在内部。
			2、外层函数将内层函数返回。
			3、调用外层函数，获得返回的内层函数对象
		
		说明：
			1、两次外层函数调用返回的闭包中，受保护的变量是各自独立的，没有任何关系。
	
		闭包为什么能留住局部变量？：
		闭包为什么能留住局部变量？：
		闭包为什么能留住局部变量？：
			外层函数的作用域对象无法释放（即没有被释放）