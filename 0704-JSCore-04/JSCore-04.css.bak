1、***数组
	1、***排序：
		1、冒泡排序：
		2、arr.sort();		
			默认：将数组中每个元素都转为字符串，再升序排序。
			何时：仅限于排序字符串时。
				（因此会遇到的问题是：当对字符串122、23排序是，会认为23>122）
			解决：
				步骤：
				1、【"自定义比较器函数"】
					比较器函数：专门比较任意两数大小的函数：
					规定：function 函数名(a,b){		//此处函数名:compare
						如果a>b就返回正数
						如果a<b就返回负数
								否则返回0
						即    return a-b;
					}
				2、将比较器函数作为参数，传入sort方法中。
					arr.sort(compare);
					【"强调：不加()"】

			sort方法的原理：
				1、"如果函数执行时缺少一段逻辑（代码段），就需要用函数类型的参数，从外部传入。"
					从外部传入的函数，在内部被调用。
					强调：将函数作为参数传递时，不加()。
				2、js的作用域  与  java的作用域
					js：2级：全局、函数作用域
						会导致：js中块中声明的变量，出了块，依然可用。甚至会被声明提前到块外。
					java：3级：全局、函数、块(if、for ...)作用域
						java中块中声明的变量，出了块，无法使用。
				3、创建函数：
					如果不希望被提前，可用：
						var 函数名=function(...){	//原为：function 函数名(){...}
							...
						}
					揭示了：函数其实也是一个对象
							函数名其实就是引用函数对象的普通变量而已。

				【颠倒比较器函数的正负号，就可改升序为降序】
					function compare(a,b){
						//return a-b;
						  return -(a-b);
					}

	2、栈和队列
		js中没有专门的栈和队列类型，都是用普通数组模拟的
		1、栈：
			一段 封闭，只能从另一端进入的数组
			FILO
			何时使用：只要希望始终使用最新加入数组的元素时，就用栈结构。
			如何使用：
				1、结尾出入栈：
					1、入栈：arr.push(值)
					2、出栈：var last=arr.pop();
						优点：每次出入栈，其余元素的位置不受影响。
				2、开头出入栈：
					1、入栈：arr.unshift(值);
					2、出栈：var first=arr.shift();
						缺点：每次出入栈，其余元素的位置都会受影响。

		2、队列：
			只能从一端进入，从另一端出
			FIFO
				1、结尾入队列：arr.push(值);
				2、开头入队列：var.first=arr.shift(); 
			何时使用：必须按照先来后到的顺序使用元素时。
	3、二维数组
		什么是二维数组：
			数组中的元素，与又引用了另一个子数组。
		何时使用：
			1、存储横行、竖列的二维数组时
			2、需要对数组中的元素进行进一步细分类时
		如何创建：
			1、在创建时，初始化数组内容：
				var arr=[[值1,值2,...],
						 [值1,值2,...],
								  ...
						]
			2、先创建空数组，再添加子数组
				var arr=[值1,值2,...];

			3、访问二维数组中的元素：
				arr[r][c];......
				强调：二维数组，行下标不能越界，回报错
				......
				for(var r=0;r<arr.length;r++){
					for(var c=0;c<arr[r].length;c++){
						arr[r][c];	//当前元素
					}
				}
2、***String：一串字符组成的只读数组
	vs	数组：
		相同点：
			1、也可以用下标访问每个字符
			2、也有length属性，表示字符的个数
			3、用for遍历每个字符
			4、凡是'不会直接修改原数组的方法'，字符串也可使用，
			   如：slice、concat
	字符串也叫内置对象
		【"内置z对象"】：ES标准中规定的，浏览器厂商已经实现的对象。
			共 11 个：
				String Number  Boolean  
				Array  Date    Math     RegExp
				Error  
				Function Object  
				Global(浏览器中被window代替了)
	***"包装类型"：专门封装原始类型的值，并提供对原始类型的值进行操作的API
		何时使用：只要试图对原始类型的值调用方法时，都会自动创建包装类型的对象，
				  来封装原始类型的值。调用的方法其实是包装类型对象的。而不是原始类型值的。
				  包装类型的对象，一旦方法执行完，就释放
			eg:
				var n=123.456;
				console.log(n.toFixed(2));
			实际上浏览器操作的是：
				var n=123.456;
				console.log(new Number(n).toFixed(2));
	String API : 所有String API都无法修改原字符串，而是返回新字符串。
		1、大小写转换：
			何时使用：在不区分大小写时
			如何转换：
				str=str.toUpperCase();	//转大写
				str=str.toLowerCase();	//转小写
		2、获取指定位置的字符：
			获取指定位置的字符：str.charAt(i)	<=>	str[i]	
			获取指定位置字符的Unicode号：str.charCodeAt(i);
















